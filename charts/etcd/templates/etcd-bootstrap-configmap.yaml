---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Values.name }}
  namespace: {{ .Release.Namespace }}
  labels:
    name: etcd
    instance: {{ .Values.name }}
{{- if .Values.labels }}
{{ toYaml .Values.labels | indent 4 }}
{{- end }}
  ownerReferences:
  - apiVersion: druid.gardener.cloud/v1alpha1
    blockOwnerDeletion: true
    controller: true
    kind: Etcd
    name: {{ .Values.name }}
    uid: {{ .Values.uid }}
data:
  bootstrap.sh: |-
    #!/bin/sh
    VALIDATION_MARKER=/var/etcd/data/validation_marker

{{- if .Values.etcd.enableTLS }}
    # Add self-signed CA to list of root CA-certificates
    cat /var/etcd/ssl/ca/ca.crt >> /etc/ssl/cert.pem
    if [ $? -ne 0 ]; then
      echo "failed to update root certificate list"
      exit 1
    fi
{{- end }}

    trap_and_propagate() {
        PID=$1
        shift
        for sig in "$@" ; do
            trap "kill -$sig $PID" "$sig"
        done
    }

    start_managed_etcd(){
          rm -rf $VALIDATION_MARKER
          etcd --name=$POD_NAME \
               --data-dir=/var/etcd/data/new.etcd \
{{- if .Values.etcd.metrics }}
                --metrics={{ .Values.etcd.metrics }} \
{{- end }}
                --snapshot-count=75000 \
                --enable-v2=false \
                --quota-backend-bytes={{ required "Values.etcd.quota is required" ( int .Values.etcd.quota ) }} \
                --listen-peer-urls=http{{ if .Values.etcd.enableTLS }}s{{ end }}://0.0.0.0:{{ required "Values.etcd.serverPort is required" .Values.etcd.serverPort }} \
                --listen-client-urls=http{{ if .Values.etcd.enableTLS }}s{{ end }}://0.0.0.0:{{ required "Values.etcd.clientPort is required" .Values.etcd.clientPort }} \
                --initial-advertise-peer-urls=http{{ if .Values.etcd.enableTLS }}s{{ end }}://$POD_IP:{{ required "Values.etcd.serverPort is required" .Values.etcd.serverPort }} \
                --advertise-client-urls=http{{ if .Values.etcd.enableTLS }}s{{ end }}://$POD_IP:{{ required "Values.etcd.clientPort is required" .Values.etcd.clientPort }} \
                --initial-cluster="{{ .Values.etcd.initialCluster }}" \
                --initial-cluster-token={{ .Values.name }} \
                --initial-cluster-state=new \
{{- if .Values.etcd.enableTLS }}
                --trusted-ca-file=/var/etcd/ssl/ca/ca.crt \
                --key-file=/var/etcd/ssl/server/tls.key \
                --cert-file=/var/etcd/ssl/server/tls.crt \
                --client-cert-auth=false
                --experimental-initial-corrupt-check=true \
                --peer-cert-file==/var/etcd/ssl/server/tls.crt \
                --peer-key-file=/var/etcd/ssl/server/tls.key \
                --peer-trusted-ca-file=/var/etcd/ssl/ca/ca.crt \
                --peer-client-cert-auth=false \
                #--peer-cert-allowed-cn= # TODO: Check if this is required and feasible
{{- end }}
                --auto-compaction-mode=periodic \
                --auto-compaction-retention="24"

          ETCDPID=$!
          trap_and_propagate $ETCDPID INT TERM
          wait $ETCDPID
          RET=$?
          echo $RET > $VALIDATION_MARKER
          exit $RET
    }

    check_and_start_etcd(){
          while true;
          do
            wget "http{{ if .Values.etcd.enableTLS }}s{{ end }}://$POD_NAME:{{ .Values.backup.port }}/initialization/status" -S -O status;
            STATUS=`cat status`;
            case $STATUS in
            "New")
                  wget "http{{ if .Values.etcd.enableTLS }}s{{ end }}://$POD_NAME:{{ .Values.backup.port }}/initialization/start?mode=$1{{- if .Values.backup.failBelowRevision }}&failbelowrevision={{ int $.Values.backup.failBelowRevision }}{{- end }}" -S -O - ;;
            "Progress")
                  sleep 1;
                  continue;;
            "Failed")
                  continue;;
            "Successful")
                  echo "Bootstrap preprocessing end time: $(date)"
                  start_managed_etcd
                  break
                  ;;
            esac;
          done
    }

    echo "Bootstrap preprocessing start time: $(date)"
    if [ ! -f $VALIDATION_MARKER ] ;
    then
          echo "No $VALIDATION_MARKER file. Perform complete initialization routine and start etcd."
          check_and_start_etcd full
    else
          echo "$VALIDATION_MARKER file present. Check return status and decide on initialization"
          run_status=`cat $VALIDATION_MARKER`
          echo "$VALIDATION_MARKER content: $run_status"
          if [ $run_status == '143' ] || [ $run_status == '130' ] || [ $run_status == '0' ] ; then
                echo "Requesting sidecar to perform sanity validation"
                check_and_start_etcd sanity
          else
                echo "Requesting sidecar to perform full validation"
                check_and_start_etcd full
          fi
    fi

  etcdbr.conf.yaml: |-
    etcdConnectionConfig:
        connectionTimeout: {{ required "Values.backup.etcdConnectionTimeout is required" .Values.backup.etcdConnectionTimeout }}
        endpoints:
          - http{{ if .Values.etcd.enableTLS }}s{{ end }}://{{ required ".Values.serviceName is required" .Values.serviceName }}:{{ required "Values.etcd.clientPort is required" .Values.etcd.clientPort }}
{{- if .Values.etcd.enableTLS }}
        # username: admin
        # password: admin
        insecureTransport: false
        insecureSkipVerify: false
        certFile: /var/etcd/ssl/client/tls.crt
        keyFile: /var/etcd/ssl/client/tls.key
        caFile: /var/etcd/ssl/client/ca.crt
{{- end }}
    serverConfig:
        port: {{ required "Values.backup.port is required" .Values.backup.port }}
{{- if .Values.etcd.enableTLS }}
        server-cert: /var/etcd/ssl/server/tls.crt
        server-key: /var/etcd/ssl/server/tls.key
{{- end }}
    leaderElectionConfig:
        retryPeriod: 5s
    snapshotterConfig:
{{- if .Values.backup.fullSnapshotSchedule }}
        schedule: {{ .Values.backup.fullSnapshotSchedule }}
{{- end }}
{{- if .Values.backup.deltaSnapshotPeriod }}
        deltaSnapshotPeriod: {{ .Values.backup.deltaSnapshotPeriod }}
{{- end }}
{{- if .Values.backup.deltaSnapshotMemoryLimit }}
        deltaSnapshotMemoryLimit: {{ int $.Values.backup.deltaSnapshotMemoryLimit }}
{{- end }}
{{- if .Values.backup.garbageCollectionPeriod }}
        garbageCollectionPeriod: {{ .Values.backup.garbageCollectionPeriod }}
{{- end}}
{{- if .Values.backup.garbageCollectionPolicy }}
        garbageCollectionPolicy: {{ .Values.backup.garbageCollectionPolicy }}
{{- if and (eq .Values.backup.garbageCollectionPolicy "LimitBased") .Values.backup.maxBackups }}
        maxBackups: {{ int $.Values.backup.maxBackups }}
{{- end }}
{{- end }}
{{- if .Values.store.storageProvider }}
    snapstoreConfig:
        provider: {{ .Values.store.storageProvider }}
        container: {{ .Values.store.container }}
{{- if .Values.store.storePrefix }}
        prefix: {{ .Values.store.storePrefix }}
{{- end }}
        tempDir: /var/etcd/data/temp
{{- end }}
    restorationConfig:
        initialCluster: "default=http://localhost:2380"
        initialClusterToken: {{ .Values.name }}
        restoreDataDir: /var/etcd/data/new.etcd
        initialAdvertisePeerURLs:
            - "http://localhost:2380"
        name: "default"
        embeddedEtcdQuotaBytes: {{ required "Values.etcd.quota is required" (int $.Values.etcd.quota) }}
{{- if .Values.etcd.defragmentationSchedule }}
    defragmentationSchedule: {{ .Values.etcd.defragmentationSchedule }}
{{- end }}